---
id: get-started
title: Get Started
description: Getting started with Casbin
keywords: [Casbin, get started, installation, usage]
authors: [nodece]
---

## Installation

<Tabs groupId="langs" items={['Go', 'Java', 'Node.js', 'PHP', 'Python', '.NET', 'C++', 'Rust', 'Delphi', 'Lua']} persist>
<Tab value="Go">

```go
go get github.com/casbin/casbin/v3
```

</Tab>
<Tab value="Java">


```xml
<!-- https://mvnrepository.com/artifact/org.casbin/jcasbin -->
<dependency>
    <groupId>org.casbin</groupId>
    <artifactId>jcasbin</artifactId>
    <version>1.x.y</version>
</dependency>
```

### GraalVM Native Image Support

If you're building a native application with GraalVM (e.g., using Quarkus or Spring Native), jCasbin requires special configuration due to its use of the [Aviator expression engine](https://github.com/killme2008/aviatorscript).

By default, Aviator uses dynamic class generation via ASM, which is not supported in GraalVM native images. To resolve this, you must configure Aviator to use interpreter mode instead of compilation mode.

#### For Quarkus applications

Add the following to your `application.properties` or `pom.xml`:

```xml
<properties>
    <quarkus.native.additional-build-args>
        -J-Daviator.eval.mode=INTERPRETER
    </quarkus.native.additional-build-args>
</properties>
```

#### For other GraalVM native builds

Set the system property when building the native image:

```bash
-Daviator.eval.mode=INTERPRETER
```

Or configure it programmatically before initializing jCasbin:

```java
System.setProperty("aviator.eval.mode", "INTERPRETER");
```

<Callout>
This configuration switches Aviator from its default compilation mode to interpreter mode. While this may have a slight performance impact, it enables full compatibility with GraalVM native images by avoiding runtime class generation.
</Callout>

</Tab>
<Tab value="Node.js">

```java
# NPM
npm install casbin --save

# Yarn
yarn add casbin
```

</Tab>
<Tab value="PHP">

```php
composer require casbin/casbin
```

</Tab>
<Tab value="Python">

```python
pip install casbin
```

</Tab>
<Tab value=".NET">

```bash
dotnet add package Casbin.NET
```

</Tab>
<Tab value="C++">

```c
# Download source
git clone https://github.com/casbin/casbin-cpp.git

# Generate project files
cd casbin-cpp && mkdir build && cd build && cmake .. -DCMAKE_BUILD_TYPE=Release

# Build and install casbin
cmake --build . --config Release --target casbin install -j 10
```

</Tab>
<Tab value="Rust">

```bash
cargo install cargo-edit
cargo add casbin

// If you use async-std as async executor
cargo add async-std

// If you use tokio as async executor, make sure you activate its `macros` feature
cargo add tokio
```

</Tab>
<Tab value="Delphi">

</Tab>
<Tab value="Lua">

```bash
luarocks install casbin
```

If you receive the error "Your user does not have write permissions in /usr/local/lib/luarocks/rocks", run the command with elevated privileges or install to your local tree using the `--local` flag:

```bash
luarocks install casbin --local
```

</Tab>
</Tabs>

<Callout>
**Migrating from v2 to v3:**

If you're upgrading from Casbin v2 to v3, update your import paths from `github.com/casbin/casbin/v2` to `github.com/casbin/casbin/v3`. This applies to all subpackages as well (e.g., `v2/model` becomes `v3/model`).

For Go modules, run:

```bash
go get -u github.com/casbin/casbin/v3
```

Then update all imports in your code from `/v2` to `/v3`.
</Callout>

## Create a Casbin Enforcer

Casbin relies on configuration files to specify the access control model.

Two configuration files are required: `model.conf` and `policy.csv`. The `model.conf` file defines your access control model, while `policy.csv` contains the specific permission rules. Working with Casbin is simpleâ€”you primarily interact with one structure: the **enforcer**. During initialization, this structure loads both configuration files automatically.

Put simply, creating a Casbin enforcer requires providing a [Model](supported-models) and an [Adapter](adapters).

Casbin provides a [FileAdapter](adapters#file-adapter-built-in) that you can use. See [Adapter](adapters) for more information.

- Example using a Model file with the default [FileAdapter](adapters#file-adapter-built-in):

<Tabs groupId="langs" items={['Go', 'Java', 'Node.js', 'PHP', 'Python', '.NET', 'C++', 'Delphi', 'Rust', 'Lua']} persist>
<Tab value="Go">

```go
import "github.com/casbin/casbin/v3"

e, err := casbin.NewEnforcer("path/to/model.conf", "path/to/policy.csv")

```

</Tab>
<Tab value="Java">

```java
import org.casbin.jcasbin.main.Enforcer;

Enforcer e = new Enforcer("path/to/model.conf", "path/to/policy.csv");

```

</Tab>
<Tab value="Node.js">

```javascript
import { newEnforcer } from 'casbin';

const e = await newEnforcer('path/to/model.conf', 'path/to/policy.csv');

```

</Tab>
<Tab value="PHP">

```php
require_once './vendor/autoload.php';

use Casbin\Enforcer;

$e = new Enforcer("path/to/model.conf", "path/to/policy.csv");

```

</Tab>
<Tab value="Python">

```python
import casbin

e = casbin.Enforcer("path/to/model.conf", "path/to/policy.csv")

```

</Tab>
<Tab value=".NET">

```csharp
using NetCasbin;

var e = new Enforcer("path/to/model.conf", "path/to/policy.csv");

```

</Tab>
<Tab value="C++">

```cpp
#include <iostream>
#include <casbin/casbin.h>

int main() {
    // Create an Enforcer
    casbin::Enforcer e("path/to/model.conf", "path/to/policy.csv");

    // your code ..
}
```

</Tab>
<Tab value="Delphi">

var
  casbin: ICasbin;
begin
  casbin := TCasbin.Create('path/to/model.conf', 'path/to/policy.csv');
  ...
end
```

</Tab>
<Tab value="Rust">

use casbin::prelude::*;

// If you use async_td as async executor
#[cfg(feature = "runtime-async-std")]
#[async_std::main]
async fn main() -> Result<()> {
    let mut e = Enforcer::new("path/to/model.conf", "path/to/policy.csv").await?;
    Ok(())
}

// If you use tokio as async executor
#[cfg(feature = "runtime-tokio")]
#[tokio::main]
async fn main() -> Result<()> {
    let mut e = Enforcer::new("path/to/model.conf", "path/to/policy.csv").await?;
    Ok(())
}
```

</Tab>
<Tab value="Lua">

local Enforcer = require("casbin")
local e = Enforcer:new("path/to/model.conf", "path/to/policy.csv") -- The Casbin Enforcer
```

</Tab>
</Tabs>

- Example using Model text with an alternative Adapter:

<Tabs groupId="langs" items={['Go', 'Python']} persist>
<Tab value="Go">

```go
import (
    "log"

    "github.com/casbin/casbin/v3"
    "github.com/casbin/casbin/v3/model"
    xormadapter "github.com/casbin/xorm-adapter/v2"
    _ "github.com/go-sql-driver/mysql"
)

// Initialize a Xorm adapter with MySQL database.
a, err := xormadapter.NewAdapter("mysql", "mysql_username:mysql_password@tcp(127.0.0.1:3306)/")
if err != nil {
    log.Fatalf("error: adapter: %s", err)
}

m, err := model.NewModelFromString(`
[request_definition]
r = sub, obj, act

[policy_definition]
p = sub, obj, act

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
m = r.sub == p.sub && r.obj == p.obj && r.act == p.act
`)
if err != nil {
    log.Fatalf("error: model: %s", err)
}

e, err := casbin.NewEnforcer(m, a)
if err != nil {
    log.Fatalf("error: enforcer: %s", err)
}

```

</Tab>
<Tab value="Python">

```python
import casbin
import casbin_sqlalchemy_adapter


# Use SQLAlchemy Casbin adapter with SQLLite DB
adapter = casbin_sqlalchemy_adapter.Adapter('sqlite:///test.db')

# Create a config model policy
with open("rbac_example_model.conf", "w") as f:
    f.write("""
    [request_definition]
    r = sub, obj, act

    [policy_definition]
    p = sub, obj, act

    [policy_effect]
    e = some(where (p.eft == allow))

    [matchers]
    m = r.sub == p.sub && r.obj == p.obj && r.act == p.act
    """)

# Create enforcer from adapter and config policy
e = casbin.Enforcer('rbac_example_model.conf', adapter)

```

</Tab>
</Tabs>

### Check permissions

Insert an enforcement check in your code immediately before resource access occurs:

<Tabs groupId="langs" items={['Go', 'Java', 'Node.js', 'PHP', 'Python', '.NET', 'C++', 'Delphi', 'Rust', 'Lua']} persist>
<Tab value="Go">

```go
sub := "alice" // the user that wants to access a resource.
obj := "data1" // the resource that is going to be accessed.
act := "read" // the operation that the user performs on the resource.

ok, err := e.Enforce(sub, obj, act)

if err != nil {
    // handle err
}

if ok == true {
    // permit alice to read data1
} else {
    // deny the request, show an error
}

// You could use BatchEnforce() to enforce some requests in batches.
// This method returns a bool slice, and this slice's index corresponds to the row index of the two-dimensional array.
// e.g. results[0] is the result of {"alice", "data1", "read"}
results, err := e.BatchEnforce([][]interface{}{{"alice", "data1", "read"}, {"bob", "data2", "write"}, {"jack", "data3", "read"}})
```

</Tab>
<Tab value="Java">

String sub = "alice"; // the user that wants to access a resource.
String obj = "data1"; // the resource that is going to be accessed.
String act = "read"; // the operation that the user performs on the resource.

if (e.enforce(sub, obj, act) == true) {
    // permit alice to read data1
} else {
    // deny the request, show an error
}
```

<Callout type="info" title="GraalVM Native Image Note">If you're running jCasbin in a GraalVM native image environment, make sure you've configured Aviator to use interpreter mode as described in the installation section above. Without this configuration, you'll encounter an `UnsupportedFeatureError` due to runtime class generation attempts.
</Callout>

</Tab>
<Tab value="Node.js">

const sub = 'alice'; // the user that wants to access a resource.
const obj = 'data1'; // the resource that is going to be accessed.
const act = 'read'; // the operation that the user performs on the resource.

if ((await e.enforce(sub, obj, act)) === true) {
    // permit alice to read data1
} else {
    // deny the request, show an error
}

</Tab>
<Tab value="PHP">

```php
$sub = "alice"; // the user that wants to access a resource.
$obj = "data1"; // the resource that is going to be accessed.
$act = "read"; // the operation that the user performs on the resource.

if ($e->enforce($sub, $obj, $act) === true) {
    // permit alice to read data1
} else {
    // deny the request, show an error
}

```

</Tab>
<Tab value="Python">

```python
sub = "alice"  # the user that wants to access a resource.
obj = "data1"  # the resource that is going to be accessed.
act = "read"  # the operation that the user performs on the resource.

if e.enforce(sub, obj, act):
    # permit alice to read data1
    pass
else:
    # deny the request, show an error
    pass

```

</Tab>
<Tab value=".NET">

```csharp
var sub = "alice";  # the user that wants to access a resource.
var obj = "data1";  # the resource that is going to be accessed.
var act = "read";  # the operation that the user performs on the resource.

if (await e.EnforceAsync(sub, obj, act))
{
    // permit alice to read data1
}
else
{
    // deny the request, show an error
}

```

</Tab>
<Tab value="C++">

```cpp
    casbin::Enforcer e("../assets/model.conf", "../assets/policy.csv");

    if (e.Enforce({"alice", "/alice_data/hello", "GET"})) {
        std::cout << "Enforce OK" << std::endl;
    } else {
        std::cout << "Enforce NOT Good" << std::endl;
    }

    if (e.Enforce({"alice", "/alice_data/hello", "POST"})) {
        std::cout << "Enforce OK" << std::endl;
    } else {
        std::cout << "Enforce NOT Good" << std::endl;
    }

```

</Tab>
<Tab value="Delphi">

```pascal
if casbin.enforce(['alice,data1,read']) then
  // Alice is super happy as she can read data1
else
  // Alice is sad

```

</Tab>
<Tab value="Rust">

```rust
  let sub = "alice"; // the user that wants to access a resource.
  let obj = "data1"; // the resource that is going to be accessed.
  let act = "read"; // the operation that the user performs on the resource.

  if e.enforce((sub, obj, act)).await? {
      // permit alice to read data1
  } else {
      // error occurs
  }

```

</Tab>
<Tab value="Lua">

```lua
if e:enforce("alice", "data1", "read") then
   -- permit alice to read data1
else
   -- deny the request, show an error
end

```

</Tab>
</Tabs>

Casbin provides APIs for runtime permission management. For instance, you can retrieve all roles assigned to a user:

<Tabs groupId="langs" items={['Go', 'Java', 'Node.js', 'PHP', 'Python', '.NET', 'Delphi', 'Rust', 'Lua']} persist>
<Tab value="Go">

```go
roles, err := e.GetRolesForUser("alice")

```

</Tab>
<Tab value="Java">

```java
List<String> roles = e.getRolesForUser("alice");

```

</Tab>
<Tab value="Node.js">

```javascript
const roles = await e.getRolesForUser('alice');

```

</Tab>
<Tab value="PHP">

```php
$roles = $e->getRolesForUser("alice");

```

</Tab>
<Tab value="Python">

```python
roles = e.get_roles_for_user("alice")

```

</Tab>
<Tab value=".NET">

```csharp
var roles = e.GetRolesForUser("alice");

```

</Tab>
<Tab value="Delphi">

```pascal
roles = e.rolesForEntity("alice")

```

</Tab>
<Tab value="Rust">

```rust
let roles = e.get_roles_for_user("alice");

```

</Tab>
<Tab value="Lua">

```lua
local roles = e:GetRolesForUser("alice")

```

</Tab>
</Tabs>

For additional usage examples, consult [Management API](/docs/management-api) and [RBAC API](/docs/rbac-api).

Additional examples can be found in the test cases.
